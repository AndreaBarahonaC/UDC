---
title: "Paquete QualityTools"
author: 
  - Miguel Flores
  - Andrea Barahona
  - Fabián Encarnación
  - Dario Quishpe
date: "`r Sys.Date()`"
output: 
  rmdformats::readthedown
---

Link: https://cran.r-hub.io/web/packages/qualityTools/vignettes/qualityTools.pdf
1. Cap 1 a Cap 4
2. Cap 5.1 a 5.5
3. Cap 5.6 hasta cap 7
Puesto 1: Andrea
Puesto 2: Fabian
Puesto 3: Dario


```{r message=FALSE, warning=FALSE, include=FALSE}
library(qualityTools)
```


<div><img src='graficos/introduccion.png' width="120" align="right"></div>

Este trabajo pretende dar una breve introducción a los métodos del paquete **QualityTools**. Este paquete se implementó con fines didácticos para servir como una "Caja de Herramientas" (Six-Sigma) y contiene métodos asociados con el ciclo de resolución con la metodología de: "Definir, Medir, Analizar, Mejorar y Controlar" (con sus siglas en inglés DMAIC). 

El uso de estos métodos se ilustran con ayuda de conjuntos de datos creados artificalmente, a continuación se explica, el objetivo de cada una de las fases de este ciclo:

* **Definir**: Describir el problema y sus consecuencias (financieras), es la etapa fundamental para delimitar el problema. Los diagramas de flujo. Los diagramas de flujo de procesos identifican elementos cruciales del proceso (es decir, actividades), las técnicas de creatividad como Brainwriting y Brainstorming, así como la técnica SIPOC4, deberían conducir, dependiendo
del tamaño futuro del proyecto, a posiblemente una carta del proyecto.

* **Medir**: Elaborar un plan razonable para recopilar los datos requeridos y asegurarse de que los sistemas de medición sean capaces (es decir, ningún sesgo o sesgo conocido y la menor variación inmanente del sistema que
contribuya a las mediciones como sea posible). Dentro de esta fase se proporciona una descripción de la situación con la ayuda de índices de capacidad de proceso o de medición (MSA5 Tipo I) o un Gage R&R (MSA Tipo II)

* **Analizar**: Intente encontrar las causas fundamentales del problema utilizando varios métodos estadísticos, como histogramas, regresión, correlación, identificación de distribución, análisis de varianza y gráficos multivariados.

* **Mejorar**: Utiliza experimentos diseñados, es decir, factoriales completos y fraccionarios, diseños de superficies de respuesta, diseños de mezclas, diseños de taguchi y el concepto de deseabilidad para encontrar
configuraciones o soluciones óptimas para un problema.

* **Controlar**: Una vez que se logró una mejora, es necesario asegurarla, lo que significa que se deben implementar acuerdos para garantizar el nivel de mejora. El uso de control estadístico de procesos (es decir, gráficos de control de calidad) se puede utilizar para monitorear el comportamiento de un proceso

# Fase 1: Definir

La mayoría de las técnicas utilizadas en esta fase no están relacionadas con el uso sustancial de métodos estadísticos. Su objetivo es captar los conocimientos e ideas sobre el proceso involucrado, establecer un objetivo común y definir cómo cada parte contribuye a la solución.

Una técnica de visualización clásica que se utiliza en esta fase y está disponible en el paquete QualityTools es el **Diagrama de Pareto**, que nos ayuda a separar las pocas causas vitales de las muchas causas triviales.

Por ejemplo, en la causa más frecuente de un producto defectuoso, el diagrama de Pareto nos ayuda a visualizar cuánto contribuye una causa a un problema. Supongamos que una empresa está investigando unidades (productos) que no cumplen. 120 unidades fueron investigadas y se encontraron 6 tipos diferentes de defectos (datos cualitativos). Los defectos son denominados de A a F por fines prácticos.

```{r fig.show='asis', results='hide', fig.align='center', fig.width=8}
defectos = c(rep("E",62),rep("B",15),rep("F",3),rep("A",10),rep("C",20),rep("D",10))
paretoChart(defectos)
```

En este diagrama de Pareto podría transmitir el mensaje de que para resolver el $68\%$ de los problemas, el $33 \%$ de las causas (menos vitales) necesitan ser objeto de investigación.

Además de este uso, los diagramas de Pareto también se utilizan para visualizar los tamaños de efectos de los diferentes factores para los experimentos diseñados, a continución se muestra un ejemplo de una gráfica de errores de medición.

<center><img src='graficos/erroresMedida.png' width = '700'></center>

# Fase 2: Medir

La recopilación de datos implica el uso de sistemas de medición a menudo denominados calibres. Para hacer una declaración sobre la calidad, el sistema de medición utilizado debe ser validado, y por lo tanto la variación para repetidas mediciones de la misma unidad debe ser tolerable, y por supuesto, debe depender del número de categorías distintivas qque necesita para poder identificar y caracterizar el producto. 

Esta cantidad tolerable de variación para un sistema de medición se relaciona directamente al rango de tolerancia de las características de un producto. 

La capacidad de un sistema de mediciones es crucial para evitar cualquier conclusión basada en datosy está directamente relacionada con los costos que implican los errores tipo I y tipo II.

## Capacidad de calibre - MSA Tipo I

## Repetibilidad y reproducibidad del calibre - MSA Tipo II

### Relación con la terminología de los sistemas de medición

# Fase 3: Analizar

## Capacidad del proceso

# Fase 4: Mejorar

## Diseños factoriales $2^{k}$

El método `facDesign` diseña un modelo de *k* factores y 2 combinaciones por factor, el cual es llamado $2^k$.

Supondremos un ejemplo de un proceso que tiene 5 factores A, B, C, D y E, de los cuales tres se consideran relevantes para el rendimiento del proceso (A, B y C).


```{r eval=FALSE}
set.seed(1)
dfac <- facDesign(k = 3, centerCube = 4)
names(dfac) <- c('Facto 1', 'Factor 2', 'Factor 3')
lows(df) <- c(80,120,1)
highs(fdo) <- c(120,140,2)
summary(dfac)
```
![](graficos/dfac.png){width=260}


El proceso se simula con el método `simProc`:

```{r}
#Primeros valores
rend <- simProc(x1=120,x2=140,x3=2)
#valores completos
rend = c(simProc(120,140,1),simProc(80,140,1),simProc(120,140,2),simProc(120,120,1),simProc(90,130,1.5),simProc(90,130,1.5),simProc(80,120,2),simProc(90,130,1.5),simProc(90,130,1.5),simProc(120,120,2),simProc(80,140,2),simProc(80,120,1))
```

Se asigna el rendimiento al diseño factorial:

```{r eval=FALSE}
response(dfac) <- rend
```

Para el análisis del diseño se puede usar los métodos `effectPlot`, `interactionPlot`, `lm`, `wirePlot`, `contourPlot`.

```{r eval=FALSE}
effectPlot(dfac, classic = TRUE)
```
![](graficos/effectplot.png){width=500}

```{r eval=FALSE}
interactionPlot(dfac)
```
![](graficos/interactionplot.png){width=500}

Se puede usar el método de R `lm`, vemos a continuación:

```{r eval=FALSE}
m1 <- lm(rend ~ A*B*C, data=dfac)
summary(m1)
```
![](graficos/lmdfac.png){width=600}

Se puede que ver que A, B y AB son significativos. 

También se puede obtener dos gráficas mediante `paretoPlot` y `normalPlot` del mismo paquete qualityTools.

```{r eval=FALSE}
par(mfrow=c(1,2))
paretoPlot(dfac)
normalPlot(dfac)
```

![](graficos/dfac2plots.png){width=700}

La relación entre el factor A y el B se puede visualizar mediante una representación 3D mediante `wirePlot` y `contourPlot`

```{r eval=FALSE}
par(mfrow=c(1,2))
wirePlot(A,B,rend,data=dfac)
contourPlot(A,B,rend,data=dfac)
```
![](graficos/dfac3d.png){width=700}

## Diseños factoriales fraccionarios $2^{k-p}$

# Diseños de superficies de respuesta

Se debe tener en cuenta que  no todas las relaciones son lineales por lo cual  para detectar y modelizar las relaciones no lineales se necesitan más de dos combinaciones por factor. Para averiguar si un diseño de superficie de respuesta es necesario (es decir, un diseño con más de dos combinaciones por factor) se puede
comparar el valor esperado de la(s) variable(s) de respuesta con la(s) observada(s) utilizando
puntos centrales . Cuanto mayor sea la diferencia entre los valores
esperados, más improbable será que  esta diferencia sea el resultado de ruido aleatorio.
Bajo el contexto del ejercicio desarrollado en la sección de diseño factorial $2^{k}$ utilizamos el método **steepAscent** de qualityTools para pasar a una mejor región del proceso. El centro de la
nueva región de proceso está definido por 144 y 165 en valores reales la cual  es el inicio del nuevo diseño.

```{r}
#Semilla
set.seed(1234)
fdo2 <- facDesign(k = 2, centerCube = 3)
names(fdo2) <- c("Factor1", "Factor2")
lows(fdo2) <- c(13, 4, 155)
highs(fdo2) <- c(15, 5, 175)
  
```
![](graficos/dario.jpg){width=700}


el rendimiento se obtiene utilizando el `simProc` y se asigna al nuevo diseño con la
ayuda del método genérico de `response` del paquete **qualityTools**

```{r}
rendimiento=c(simProc(134,175),simProc(144.5,165.5),simProc(155,155),simProc(144.5,165.5),simProc(155,175),simProc(144.5,165.5),simProc(134,155))
response(fdo2)=rendimiento
```
Si se observan los gráficos de residuos, se apreciará una diferencia sustancial entre los valores esperados
y los valores observados (podría realizarse una prueba de falta de ajuste para verificarlo).
Para llegar a un modelo que describa la relación hay que añadir más puntos
que se denominan la **starportion** del diseño de la superficie de respuesta.
La adición de la **starportion** se realiza fácilmente utilizando el método `starDesign` del paquete **qualityTools**
Por defecto, el valor de alfa se elige de forma que ambos criterios, ortogonalidad y
rotatabilidad se cumplan . Se llama al método starDesign en el objeto de diseño factorial
factorial `fdo2`. La llamada a `rsdo` le mostrará el diseño de superficie de respuesta resultante.Debe tener una porción cúbica que conste de 4 runs, 3 puntos centrales en la porción cúbica, 4
axiales y 3 puntos centrales en la porción de estrella (**starportion**).

```{r}
rsdo= starDesign( data =fdo2 )
rsdo
```
| StandOrd | RunOrder | Block | A     | B     | rendimiento |
|----------|----------|-------|-------|-------|------------ |
| 3        | 3        | 1     | 1     | -1.000| 3769        |
| 7        | 7        | 2     | 1     | 0.000 | 7953        |
| 2        | 2        | 3     | 1     | -1.000| 7935        |
| 6        | 6        | 4     | 1     | 0.000 | 7865        |
| 4        | 4        | 5     | 1     | 1.000 | NA          |
| 5        | 5        | 6     | 1     | 0.000 | NA          |
| 1        | 1        | 7     | 1     | -1.000| NA          |
| 8        | 8        | 8     | 2     | -1.414| NA          |
| 9        | 9        | 9     | 2     | 1.000 | NA          |
| 10       | 10       | 10    | 2     | 0.000 | NA          |
| 11       | 11       | 11    | 2     | 0.000 | NA          |
| 12       | 12       | 12    | 2     | 0.000 | NA          |
| 13       | 13       | 13    | 2     | 0.000 | NA          |
| 14       | 14       | 14    | 2     | 0.000 | NA          |



Utilizando el método estrella del paquete **qualityTools** se pueden ensamblar fácilmente diseños
secuencialmente. Esta estrategia secuencial ahorra recursos pues, en comparación con empezar con
diseño de superficie de respuesta desde el principio, la parte en estrella sólo se ejecuta si es realmente necesaria. Los rendimientos del proceso siguen estando dados por el método `simProc`.

```{r}

yield2 <- c(
  yield,
  simProc(130, 165),
  simProc(155, 165),
  simProc(144, 155),
  simProc(144, 179),
  simProc(144, 165),
  simProc(144, 165),
  simProc(144, 165)
)

response(rsdo) <- yield2

```

Se ajusta un modelo cuadrático completo utilizando el método **lm**

```{r}
lm.3 <- lm(yield2 ~ A*B + I(A^2) + I(B^2), data = rsdo)

```
La superficie de respuesta puede visualizarse utilizando `wirePlot` y `contourPlot`.

```{r}
par(mfrow = c(1, 2))
wirePlot(A, B, yield2, form = "yield2 ~ A*B + I(A^2) + I(B^2)", data = rsdo, theta = -70)
contourPlot(A, B, yield2, form = "yield2 ~ A*B + I(A^2) + I(B^2)", data = rsdo)

```

![](graficos/dario1.jpg){width=700}
![](graficos/dario2.jpg){width=700}

Se compara los resultados de los diseños factorial y de superficie de respuesta con el proceso simulado.


Se pueden crear diseños de superficie de respuesta utilizando el método `rsmDesign`. Por ejemplo un diseño con alfa = 1.633, 0 puntos centrales en la parte del cubo y 6 puntos centrales en la parte de la estrella con:

```{r}
fdo <- rsmDesign(k = 3, alpha = 1.633, cc = 0, cs = 6)

```
y el diseño se puede poner en orden estándar utilizando el método `randomize` con el argumento `so=TRUE` (es decir, orden estándar). `cc` significa centerCube y `cs` para centerStar.


```{r}

fdo <- randomizeDesign(fdo, so = TRUE)

```


Los diseños de superficie de respuesta también pueden elegirse a partir de una tabla utilizando el método `rsmChoose`.

```{r}
rsdo <- rsmDesign()
```

## Montaje secuencial de diseños de superficie de respuesta

El ensamblaje secuencial es una característica  importante de los diseños de superficie de respuesta. En función de de las características del diseño factorial (fraccional) puede aumentarse una porción de estrella utilizando el método `starDesign`. Una porción en estrella consta de recorridos axiales
y puntos centrales opcionales (`cs`) en la parte axial a diferencia de los puntos centrales (`cc`) en la parteparte cúbica.

```{r}
fdo3 <- facDesign(k = 6)
rsdo <- starDesign(alpha = "orthogonal", data = fdo3)
```

En caso de que no se entregue ningún diseño factorial (fraccional)  al método `starDesign`, se devuelve una lista con `data.frames` que pueden asignarse al diseño factorial (fraccional) existente utilizando los métodos `star`, `centerStar` y `centerCube`.


![](graficos/dario3.jpg){width=700}

## Aleatorización

La aleatorización se consigue utilizando el método `randomize`.
Es necesario suministrar una semilla aleatoria (random.seed) que es útil para tener el mismo orden de ejecución en cualquier máquina.

```{r}
randomize(fdo, random.seed = 123)

```
El método `randomize`  se puede utilizar para obtener un diseño en orden estándar con la ayuda del argumento `so`.

```{r}
randomizeDesign(fdo, so = TRUE)

```
## Bloqueo

El bloqueo es otra característica relevante y puede conseguirse mediante el método de `blocking`. Bloquear un diseño a posteriori no siempre tiene éxito.
Sin embargo, no es problemático durante el montaje secuencial.

# Deseabilidades

Muchos problemas requieren  optimización simultánea de más de una variable de respuesta. La optimización puede lograrse maximizando o minimizando el valor de la respuesta o tratando de situar la respuesta en un objetivo específico.En la  Optimización mediante el enfoque de las deseabilidades Derringer y Suich [1980], los valores (predichos) de las variables de respuesta se transforman en valores dentro del intervalo [0,1] utilizando tres métodos de deseabilidad diferentes
para los tres criterios de optimización diferentes (es decir, minimizar, maximizar, objetivo). A cada valor de una variable de respuesta se le puede asignar una deseabilidad específica, optimizando más de una variable de respuesta. La media geométrica de las deseabilidades específicas caracteriza la deseabilidad global.

\[\sqrt[n]{\prod^n_{i=1}d_i}\]

 Para los valores previstos de las respuestas, cada combinación de factores tiene una correspondiente deseabilidad específica y se puede calcular una deseabilidad global. Supongamos que tenemos 
tres respuestas. Para un ajuste específico de los factores, las respuestas tienen deseabilidades
como $d1 = 0,7$ para $y1, d2 = 0,8$ para $y2$ y $d3 = 0,2$ para $y3$. La deseabilidad global 
viene dada por la media geométrica.

\[d_{all}=\sqrt[n]{d_1d_2\ldots d_n}\]
\[=\sqrt[3]{d_1d_2\ldots d_n}\]
\[=\sqrt[n]{0.7\cdot0.8\cdot0.2}\]


Los métodos de deseabilidad pueden definirse mediante el método `desires`. La dirección de optimización de cada variable de respuesta se define mediante los argumentos `min`,`max` y `target` del método `desires`. El argumento `target` se establece con `max` para la maximización, `min` para la minimización y un valor específico para la optimización hacia un objetivo concreto. De esta constelación surgen tres ajustes:


**target = max:** min es el valor mínimo aceptable. Si la variable de respuesta toma valores por debajo de min, la deseabilidad correspondiente será cero. Para valores iguales o mayores que min, la deseabilidad será mayor que cero.

**target = min:** max es el valor máximo aceptable. Si la variable de respuesta toma valores por encima de max, la deseabilidad correspondiente será cero. Para valores iguales o menores que max, la deseabilidad será mayor que cero.

**target = valor:** una variable de respuesta con un valor de valor se relaciona con la deseabilidad más alta alcanzable de 1. Los valores fuera de min o max llevan a una deseabilidad de cero, dentro de min y max a valores dentro de (0,1].



```{r}
#EJEMPLO:

d1 <- desirability(y1, 120, 170, scale = c(1, 1), target = "max")
d3 <- desirability(y3, 400, 600, target = 500)
d1
par(mfrow = c(1, 2))
plot(d1, col = 2)
plot(d3, col = 2)

```

# Utilización de deseabilidades junto con experimentos diseñados

La metodología de la deseabilidad se apoya en los objetos de diseño factorial. El resultado
del método de deseabilidad puede almacenarse en el objeto de diseño, de modo que la información que
pertenece a cada uno se almacena en el mismo lugar (es decir, el propio diseño). 

**Experimento**
Los datos utilizados proceden de Derringer y Suich [1980]. Se definieron cuatro respuestas $y_1, y_2, y_3$ e $y_4$.
Los factores utilizados en este experimento fueron la sílicio, el silano y el azufre con ajustes de factor alto de $1,7, 60, 2,8$ y factores bajos de $0,7, 40, 1,8$. Se desea maximizar $y_1$ e $y_2$
 e $y_3$ e $y_4$ fijados en un objetivo específico.
En primer lugar, se crea el diseño correspondiente y a  continuación, utilizamos el método `randomize` para obtener el orden estándar del diseño.

```{r}
ddo <- rsmDesign(k = 3, alpha = 1.633, cc = 0, cs = 6)
ddo <- randomize(ddo, so = TRUE)

# Opcional
names(ddo) <- c("silica", "silan", "sulfur")

# Opcional
highs(ddo) <- c(1.7, 60, 2.8)

# Opcional
lows(ddo) <- c(0.7, 40, 1.8)

#

y1 <- c(102, 120, 117, 198, 103, 132, 132, 139, 102, 154, 96, 163, 116, 153, 133, 133, 140, 142, 145, 142)
y2 <- c(900, 860, 800, 2294, 490, 1289, 1270, 1090, 770, 1690, 700, 1540, 2184, 1784, 1300, 1300, 1145, 1090, 1260, 1344)
y3 <- c(470, 410, 570, 240, 640, 270, 410, 380, 590, 260, 520, 380, 520, 290, 380, 380, 430, 430, 390, 390)
y4 <- c(67.5, 65, 77.5, 74.5, 62.5, 67, 78, 70, 76, 70, 63, 75, 65, 71, 70, 68.5, 68, 68, 69, 70)


```
El `data.frame` ordenado de estas 4 respuestas se asigna al objeto de diseño `ddo`.

```{r}
response(ddo) <- data.frame(y1, y2, y3, y4)[c(5, 2, 3, 8, 1, 6, 7, 4, 9:20), ]

```


# Bibliografía 

* Roth, T. (2016). Working with the qualityTools package.
* Six Sigma Daily (2012). What is DMAIC?. recuperado de: https://www.sixsigmadaily.com/what-is-dmaic/





